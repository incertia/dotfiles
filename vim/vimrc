"" tab stuff
set ts=4 sw=4 sts=4 expandtab

" 256 colors
set t_Co=256

"" other stuff
set scrolloff=2
set title
set matchtime=1
set nowrap
set showmatch
let mapleader="\\"
let localleader=","

" "" smart indentation
" set smartindent

" latex should be default
let g:tex_flavor = "latex"

"" text width
set textwidth=72
set wrap

"" show unwanted whitespace
set list listchars=tab:\|\ ,trail:.

"" syntax highlighting
syntax enable

"" show line numbers
set number

"" autocmd stuff
if has("autocmd")
    " Uncomment the following to have Vim jump to the last position when
    " reopening a file
    au BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g'\"" | endif

    " Set scripts to be executable from the shell
    au BufWritePost * if getline(1) =~ "^#!" | if getline(1) =~ "/bin/" | silent execute "!chmod +x %" | endif | endif
    au BufWritePost * if getline(1) =~ "^#!" | if getline(1) =~ "zsh" | silent execute "setfiletype zsh" | endif | endif

    " Uncomment the following to have Vim load indentation rules and plugins
    " according to the detected filetype.
    filetype plugin indent on

    "" I don't know what this does
    au BufWrite * mkview
    au BufRead * silent loadview

    " Uncomment the following line to disable auto commenting
    au FileType * setlocal formatoptions-=c formatoptions-=r formatoptions-=o
endif

"folding settings
set foldmethod=indent   " fold based on indent
set foldnestmax=16      " deepest fold is 16 levels
set nofoldenable        " don't fold by default
set foldlevel=1         " yay

" number formats
set nf=alpha,octal,hex

" map <F1> to deleting trailing whitespace and clearing empty lines
function! KillWhiteThings()
    let save_cursor = getpos(".")
    :silent! %s#\($\n\s*\)\+\%$##
    :silent! %s/\s\+$//g
    call setpos('.', save_cursor)
endfunction

nnoremap <silent> <F1>  :call KillWhiteThings()<CR>

" easy key to turn off search highlight once we are done
nnoremap <silent> <F2>  :set hlsearch! hlsearch?<CR>

" kill all other unmodified tabs
nnoremap <silent> <F3>  :tabonly<CR>

" kill the current tab
nnoremap <silent> <F4>  :q!<CR>

" emacs <C-x><C-c> with prompt is really nice
nnoremap <C-x><C-x>     :confirm qa<CR>

" switch files with arrow keys
nnoremap <DOWN>         :bnext<CR>
nnoremap <UP>           :bprev<CR>

" tabs
nnoremap <C-t>          :tabnew<SPACE>
nnoremap <C-y>          :tabnew<CR>
nnoremap <TAB>          gt
nnoremap <S-TAB>        gT

" map space to executing the q macro for easy qq recording
nnoremap <SPACE>        @q

" map enter to execute the a macro
nnoremap <CR>           @a

" who cares about ex mode. map QQ to reflow paragraphs
" nnoremap QQ             gqap
" vnoremap QQ             gq

" save shortcut
inoremap <C-s>          <ESC>:w!<CR>a
nnoremap <C-s>          :w!<CR>

" split workflow
nnoremap <C-h>          <C-w>h
nnoremap <C-j>          <C-w>j
nnoremap <C-k>          <C-w>k
nnoremap <C-l>          <C-w>l
nnoremap <leader>-      <C-w>-
nnoremap <leader>=      <C-w>+
" because we remmaped <C-l>
nnoremap <C-m>          <C-l>

" scroll up to <C-q> (don't need this to be visual block)
nnoremap <C-q>          <C-y>

" this helps with long lines
nnoremap j              gj
nnoremap k              gk
nnoremap gj             j
nnoremap gk             k

function! Scroll(dir)
    let lines = winheight(0)

    if(a:dir == "up")
        let cmd = "\<C-y>"
    elseif(a:dir == "down")
        let cmd = "\<C-e>"
    else
        let cmd = "\<Esc>"
    endif

    call feedkeys(lines . cmd, "n")
endfunction

" change this emacs binding because j/k is more useful
nnoremap <silent> <C-n> :call Scroll("down")<CR>
nnoremap <silent> <C-p> :call Scroll("up")<CR>

" 2 line status bar
set laststatus=2

" good public/private indents?
set cinoptions=g-1,:0,(0

"" All of the following settings were taken from Damian Conway
"====[ Make the 81st column stand out ]====================

    " EITHER the entire 81st column, full-screen
    " highlight ColorColumn ctermbg=magenta
    " set colorcolumn=81

    " OR ELSE just the 81st column of wide lines
    highlight ColorColumn ctermbg=magenta
    call matchadd('ColorColumn', '\%81v', 100)


""=====[ Highlight matches when jumping to next ]=============
"
"    " This rewires n and N to do the highlighing
"    nnoremap <silent> n   n:call HLNext(0.4)<cr>
"    nnoremap <silent> N   N:call HLNext(0.4)<cr>
"
"
"    " OR ELSE just highlight the match in red
"    function! HLNext (blinktime)
"        let [bufnum, lnum, col, off] = getpos('.')
"        let matchlen = strlen(matchstr(strpart(getline('.'),col-1),@/))
"        let target_pat = '\c\%#'.@/
"        let ring = matchadd('WhiteOnRed', target_pat, 101)
"        redraw
"        exec 'sleep ' . float2nr(a:blinktime * 1000) . 'm'
"        call matchdelete(ring)
"        redraw
"    endfunction


"====[ Swap : and ; to make colon commands easier to type ]======

    nnoremap  ;  :
    nnoremap  :  ;
    vnoremap  ;  :
    vnoremap  :  ;


"====[ Swap v and CTRL-V, because Block mode is more useful that Visual mode "]======

    nnoremap    v   <C-V>
    nnoremap <C-V>     v

    vnoremap    v   <C-V>
    vnoremap <C-V>     v


"====[ Open any file with a pre-existing swapfile in readonly mode "]=========

"    augroup NoSimultaneousEdits
"        autocmd!
"        autocmd SwapExists * let v:swapchoice = 'o'
"        autocmd SwapExists * echomsg ErrorMsg
"        autocmd SwapExists * echo 'Duplicate edit session (readonly)'
"        autocmd SwapExists * echohl None
"        autocmd SwapExists * sleep 2
"    augroup END
"
"    " Also consider the autoswap_mac.vim plugin (but beware its limitations)

runtime plugin/dragvisuals.vim

vmap  <expr>  <LEFT>   DVB_Drag('left')
vmap  <expr>  <RIGHT>  DVB_Drag('right')
vmap  <expr>  <DOWN>   DVB_Drag('down')
vmap  <expr>  <UP>     DVB_Drag('up')
vmap  <expr>  D        DVB_Duplicate()

" Remove any introduced trailing whitespace after moving
let g:DVB_TrimWS = 1

" vimacs
" let g:VM_CmdHeightAdj = 0
" let g:VM_Enabled = 1

" pathogen
execute pathogen#infect()

if has("autocmd")
    au CompleteDone * pclose
endif
let g:ycm_min_num_of_chars_for_completion = 4

" set the colorscheme to solarized-256
if has("gui_running")
    set background=light
else
    set background=dark
    let g:solarized_termcolors  = 256
    let g:solarized_termtrans   = 1
    let g:solarized_visibility  = "normal"
endif
colorscheme solarized
