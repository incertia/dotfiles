"" editing
set ts=2 sw=2 sts=2 et ai number
set cinoptions=g-1,:0,(0

" appearance
set t_Co=256 title scrolloff=2 wrap showmatch tw=0
set list listchars=tab:\|\ ,trail:.
set laststatus=2
syntax on

"" other stuff
set matchtime=1
let mapleader="\\"
let localleader=","
set sessionoptions-=options

" latex should be default
let g:tex_flavor = "latex"

" tab navigation
function! TabSwitch(tabnum)
  call feedkeys(a:tabnum . "gt", "n")
endfunction

" leader command section
nnoremap <leader>so     :so<SPACE>%<CR>
nnoremap <leader>vc     :e<SPACE>~/.vim/vimrc<CR>
nnoremap <leader>la     :e<SPACE>~/texmf/tex/latex/incertia/incertia.sty<CR>
nnoremap <leader>;      m`A;<ESC>``

" :Tab commands
command! -nargs=1 TabSwitch :call TabSwitch(<f-args>)

" tab bindings
nnoremap <C-x><C-t>          :TabSwitch<SPACE>
nnoremap <C-x>t              :TabSwitch<SPACE>
nnoremap <leader>1           1gt
nnoremap <leader>2           2gt
nnoremap <leader>3           3gt
nnoremap <leader>4           4gt
nnoremap <leader>5           5gt
nnoremap <leader>6           6gt
nnoremap <leader>7           7gt
nnoremap <leader>8           8gt
nnoremap <leader>9           9gt
nnoremap <silent> <leader>0  :tablast<CR>

let g:tabmoveleft_cmd  = ":-tabmove\<CR>"
let g:tabmoveright_cmd = ":+tabmove\<CR>"
nnoremap <silent> <leader>hh @=g:tabmoveleft_cmd<CR>
nnoremap <silent> <leader>ll @=g:tabmoveright_cmd<CR>
nnoremap <leader>j           gt
nnoremap <leader>k           gT

" surround.vim
nmap <leader>ds  <Plug>Dsurround
nmap <leader>cs  <Plug>Csurround
nmap <leader>cS  <Plug>CSurround
nmap <leader>ys  <Plug>Ysurround
nmap <leader>yS  <Plug>YSurround
nmap <leader>yss <Plug>Yssurround
nmap <leader>ySs <Plug>YSsurround
nmap <leader>ySS <Plug>YSsurround
xmap <leader>S   <Plug>VSurround
xmap <leader>gS  <Plug>VgSurround

" windowswap
let g:windowswap_map_keys = 0
nnoremap <silent> <leader>ww :call WindowSwap#EasyWindowSwap()<CR>

" tabularize
let g:haskell_tabular = 1
vnoremap a= :Tabularize /=<CR>
vnoremap a; :Tabularize /::<CR>
vnoremap a- :Tabularize /-><CR>

"" autocmd stuff
if has("autocmd")
  " Uncomment the following to have Vim jump to the last position when
  " reopening a file
  au BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g'\"" | endif

  " Set scripts to be executable from the shell
  au BufWritePost * if getline(1) =~ "^#!" | if getline(1) =~ "/bin/" | silent execute "!chmod +x %" | endif | endif
  au BufWritePost * if getline(1) =~ "^#!" | if getline(1) =~ "zsh" | silent execute "setfiletype zsh" | endif | endif

  " Uncomment the following to have Vim load indentation rules and plugins
  " according to the detected filetype.
  filetype plugin indent on

  "" I don't know what this does
  au BufWrite * mkview
  au BufRead * silent loadview

  " Uncomment the following line to disable auto commenting
  au FileType * setlocal formatoptions-=c formatoptions-=r formatoptions-=o

  " disable haskell-vim omnifunc
  let g:haskellmode_completion_ghc = 0
  let g:necoghc_enable_detailed_browse = 1
  au FileType haskell setlocal omnifunc=necoghc#omnifunc
endif

"folding settings
set foldmethod=indent   " fold based on indent
set foldnestmax=16      " deepest fold is 16 levels
set nofoldenable        " don't fold by default
set foldlevel=1         " yay

" number formats
set nf=alpha,octal,hex
nnoremap <C-x> <nop>
nnoremap <C-d> <C-x>

" split to the right and below
set splitbelow splitright

" map <F1> to deleting trailing whitespace and clearing empty lines
function! KillWhiteThings()
  let save_cursor = getpos(".")
  :silent! %s#\($\n\s*\)\+\%$##
  :silent! %s/\s\+$//g
  call setpos('.', save_cursor)
endfunction

nnoremap <silent> <F1>  :call KillWhiteThings()<CR>
nnoremap <silent> <F2>  :set hlsearch! hlsearch?<CR>
nnoremap <silent> <F3>  :tabonly<CR>
nnoremap <silent> <F4>  :q!<CR>

" reflow bindings
nnoremap Q              gqgq
vnoremap Q              gq

" emacs <C-x><C-c> with prompt is really nice
nnoremap <C-x><C-x>     :confirm qa<CR>

" switch files with arrow keys
nnoremap <DOWN>         :bnext<CR>
nnoremap <UP>           :bprev<CR>

" tabs
nnoremap <C-t>          :tabnew<SPACE>
let g:newtab_command = ":tabnew\<CR>"
nnoremap <C-y>          @=g:newtab_command<CR>
nnoremap <S-TAB>        gt

" map space to executing the q macro for easy qq recording
nnoremap <SPACE>        @q

" map enter to execute the a macro
nnoremap <CR>           @a

" who cares about ex mode. map QQ to reflow paragraphs
" nnoremap QQ             gqap
" vnoremap QQ             gq

" save shortcut
inoremap <C-s>          <ESC>:w!<CR>a
nnoremap <C-s>          :w!<CR>

" split workflow
nnoremap <C-h>          <C-w>h
nnoremap <C-j>          <C-w>j
nnoremap <C-k>          <C-w>k
nnoremap <C-l>          <C-w>l
nnoremap <leader>-      <C-w>-
nnoremap <leader>=      <C-w>+
" because we remmaped <C-l>
nnoremap <C-m>          <C-l>

" scroll up to <C-q> (don't need this to be visual block)
nnoremap <C-q>          <C-y>

" this helps with long lines
nnoremap j              gj
nnoremap k              gk
nnoremap gj             j
nnoremap gk             k
vnoremap j              gj
vnoremap k              gk
vnoremap gj             j
vnoremap gk             k

function! Scroll(dir)
  let lines = winheight(0)

  if(a:dir == "up")
    let cmd = "\<C-y>"
  elseif(a:dir == "down")
    let cmd = "\<C-e>"
  else
    let cmd = "\<Esc>"
  endif

  call feedkeys(lines . cmd, "n")
endfunction

" change this emacs binding because j/k is more useful
nnoremap <silent> <C-n> :call Scroll("down")<CR>
nnoremap <silent> <C-p> :call Scroll("up")<CR>

"" All of the following settings were taken from Damian Conway
"====[ Make the 81st column stand out ]====================

" EITHER the entire 81st column, full-screen
" highlight ColorColumn ctermbg=magenta
" set colorcolumn=81

" OR ELSE just the 81st column of wide lines
highlight ColorColumn ctermbg=magenta
call matchadd('ColorColumn', '\%81v', 100)

nnoremap  ;  :
nnoremap  :  ;
vnoremap  ;  :
vnoremap  :  ;
nnoremap    v   <C-V>
nnoremap <C-V>     v
vnoremap    v   <C-V>
vnoremap <C-V>     v

" sest variables before running pathogen
let g:ycm_min_num_of_chars_for_completion = 4
let g:ycm_key_list_select_completion = [ "<Down>", ]
let g:ycm_key_list_previous_completion = [ "<Up>", ]
let g:ycm_confirm_extra_conf = 0
let g:ycm_semantic_triggers = {'haskell' : ['.']}
let g:ycm_rust_src_path = "/usr/local/rust/rustc-1.10.0/src"
let g:rust_recommended_style = 0
let g:EclimCompletionMethod = 'omnifunc'
let g:ghcmod_type_highlight = "Normal"
let g:surround_no_mappings = 1
let b:surround_indent = 0

" pathogen
execute pathogen#infect()

if has("autocmd")
  au CompleteDone * pclose
endif

" set the colorscheme to solarized-256
if has("gui_running")
  set background=light
else
  set background=dark
  let g:solarized_termcolors  = 256
  let g:solarized_termtrans   = 1
  let g:solarized_visibility  = "normal"
endif
colorscheme solarized

" enable powerline if it exists and we are not in a tty
if !(&term=~'linux') && isdirectory(expand("~/.vim/powerline"))
  set rtp+=~/.vim/powerline/powerline/bindings/vim/
endif
