" editing
set guicursor=
set undofile

" this fixes excessive "Pattern not found" messages
set shm+=c

" menuone: popup even if there is only one match
" noinsert: do not insert selection until accepted
" noselect: do not automatically select
set completeopt+=menuone,noinsert,noselect

" other stuff
set matchtime=2
set sessionoptions-=options

" latex should be default
let g:tex_flavor = "latex"

" vim-plug
call plug#begin('~/.vim/plugged')

Plug 'Shougo/vimproc.vim',          { 'do': 'make' }

" completion plugin
if has('nvim')
  Plug 'Shougo/deoplete.nvim', { 'do' : ':UpdateRemotePlugins' }
  let g:deoplete#enable_at_startup = 1
  " Plug 'neovim/nvim-lspconfig'
  " set omnifunc=v:lua.vim.lsp.omnifunc
else
  " mucomplete
  Plug 'lifepillar/vim-mucomplete'
endif

" statusline plugin as powerline does not work for neovim
if has('nvim')
  Plug 'nvim-lualine/lualine.nvim'
endif

" echos docstrings
Plug 'Shougo/echodoc'
if has('nvim')
  let g:echodoc#type = 'floating'
else
  let g:echodoc#type = "echo"
endif
let g:echodoc#enable_at_startup = 1

" language plugins
Plug 'petRUShka/vim-sage',          { 'for': 'sage'     }
let g:rust_recommended_style = 0

Plug 'tpope/vim-repeat'
Plug 'tpope/vim-surround'
let g:surround_no_mappings = 1
let b:surround_indent = 0

" :Bd to close buffers without closing the window
Plug 'moll/vim-bbye'

Plug 'sotte/presenting.vim'

Plug 'scrooloose/nerdtree',         { 'on': 'NERDTreeToggle' }
Plug 'godlygeek/tabular',           { 'on': 'Tabularize' }
let g:haskell_tabular = 1

call plug#end()

" tab navigation
function! TabSwitch(tabnum)
  call feedkeys(a:tabnum . "gt", "n")
endfunction
command! -nargs=1 TabSwitch :call TabSwitch(<f-args>)

filetype plugin indent on

set viewoptions-=options

" folding settings
set foldmethod=indent   " fold based on indent
set foldnestmax=16      " deepest fold is 16 levels
set nofoldenable        " don't fold by default
set foldlevel=100       " yay

" number formats
set nf=alpha,octal,hex

" autocmd stuff
if has("autocmd")
  " Set scripts to be executable from the shell
  augroup shell_execute
    autocmd!
    autocmd BufWritePost * if getline(1) =~ "^#!" | if getline(1) =~ "/bin/" | silent execute "!chmod +x %" | endif | endif
    autocmd BufWritePost * if getline(1) =~ "^#!" | if getline(1) =~ "zsh" | silent execute "setfiletype zsh" | endif | endif
  augroup END

  " save/restore views when exiting/entering vim
  augroup buffer_view
    autocmd!
    autocmd BufWrite * mkview
    autocmd BufRead * silent! loadview
  augroup END

  " tags the textwidth + 1 column to ColorColumn and highlights it white
  function ColorColumn()
    let l:color_fmt = printf("\\%%%dv", &textwidth + 1)
    if exists("w:color_id")
      call matchdelete(w:color_id)
      call matchadd('ColorColumn', l:color_fmt, 100, w:color_id)
    else
      let w:color_id = matchadd('ColorColumn', l:color_fmt, 100)
    endif
  endfunction

  augroup color_column
    autocmd!
    autocmd BufEnter,WinEnter * call ColorColumn()
    autocmd OptionSet textwidth call ColorColumn()
  augroup END

  " textwidth on tex should be 80
  augroup text_width
    autocmd!
    autocmd FileType tex setlocal textwidth=80
  augroup END

  " some markdown stuff
  augroup markdown
    autocmd!
    autocmd FileType markdown
      \ setlocal formatoptions-=q |
      \ setlocal formatlistpat=^\\s*\\d\\+\\.\\s\\+\\\|^\\s*\[-*+]\\s\\+
  augroup END

  augroup completion
    autocmd!
    autocmd CompleteDone * pclose
  augroup END

  augroup colorschemes
    autocmd!
    " disable background highlighting for SpellBad, etc, because underlines are enough
    " we have to do this after we :colorscheme because most colorschemes call :hi clear which will reset the
    " highlighting back to the defaults, and if a colorscheme does not touch the background, it can cause conflicts with
    " linters that utilize SpellBad, etc
    autocmd ColorScheme * call s:base16_customize()
  augroup END
endif

function! s:base16_customize() abort
  hi ColorColumn ctermbg=white
endfunction

" function to delete trailing whitespace
function! KillWhiteThings()
  let save_cursor = getpos(".")
  :silent! %s#\($\n\s*\)\+\%$##
  :silent! %s/\s\+$//g
  call setpos('.', save_cursor)
endfunction

" KEYBINDS YAY

" funciton keys
nnoremap <silent> <F1>   :call KillWhiteThings()<CR>
nnoremap <silent> <F2>   :set hlsearch! hlsearch?<CR>

" reflow bindings
nnoremap Q               gqgq
vnoremap Q               gq

" switch files with arrow keys
nnoremap <silent> <DOWN> :bnext<CR>
nnoremap <silent> <UP>   :bprev<CR>

" tabs
nnoremap <C-t>           :tabnew<SPACE>
let g:newtab_command = ":tabnew\<CR>"
nnoremap <silent> <C-y>  @=g:newtab_command<CR>
nnoremap <S-TAB>         gt

" map space to executing the q macro for easy qq recording
nnoremap <SPACE>         @q

" because we remmaped <C-l>
nnoremap <leader><C-l>   <C-l>

" this helps with long lines
" nnoremap <silent> j  gj
" nnoremap <silent> k  gk
" nnoremap <silent> gj j
" nnoremap <silent> gk k
" vnoremap <silent> j  gj
" vnoremap <silent> k  gk
" vnoremap <silent> gj j
" vnoremap <silent> gk k

" leader command section
nnoremap <silent> <leader>so      :so<SPACE>%<CR>
nnoremap <silent> <leader>vc      :e<SPACE>~/.vim/vimrc<CR>
nnoremap <silent> <leader>la      :e<SPACE>~/texmf/tex/latex/incertia/incertia.sty<CR>

" this adds a semicolon to the current line
nnoremap <silent> <leader>;       m`A;<ESC>``

nnoremap <silent> <leader>n  :NERDTreeToggle<CR>

" tab bindings
nnoremap <leader>1          1gt
nnoremap <leader>2          2gt
nnoremap <leader>3          3gt
nnoremap <leader>4          4gt
nnoremap <leader>5          5gt
nnoremap <leader>6          6gt
nnoremap <leader>7          7gt
nnoremap <leader>8          8gt
nnoremap <leader>9          9gt
nnoremap <silent> <leader>0 :tablast<CR>

let g:tabmoveleft_cmd  = ":-tabmove\<CR>"
let g:tabmoveright_cmd = ":+tabmove\<CR>"
nnoremap <silent> <leader>hh @=g:tabmoveleft_cmd<CR>
nnoremap <silent> <leader>ll @=g:tabmoveright_cmd<CR>
nnoremap <leader>j           gt
nnoremap <leader>k           gT

" surround.vim
nmap <leader>ds  <Plug>Dsurround
nmap <leader>cs  <Plug>Csurround
nmap <leader>cS  <Plug>CSurround
nmap <leader>ys  <Plug>Ysurround
nmap <leader>yS  <Plug>YSurround
nmap <leader>yss <Plug>Yssurround
nmap <leader>ySs <Plug>YSsurround
nmap <leader>ySS <Plug>YSsurround
xmap <leader>S   <Plug>VSurround
xmap <leader>gS  <Plug>VgSurround

" haskell tabularize bindings
vnoremap a= :Tabularize /=<CR>
vnoremap a; :Tabularize /::<CR>
vnoremap a- :Tabularize /-><CR>

" set the colorscheme
if has("gui_running")
  set background=light
  set guioptions-=T
  set guioptions-=m
  set guifont=DejaVu\ Sans\ Mono\ for\ Powerline\ 9
endif

" enable powerline if it exists and we are not in a tty
if (!has('nvim') && !(&term=~'linux') && isdirectory(expand("~/.vim/powerline"))) || has("gui_running")
  set rtp+=~/.vim/powerline/powerline/bindings/vim/
endif

function! SynStack()
  for i1 in synstack(line("."), col("."))
    let i2 = synIDtrans(i1)
    let n1 = synIDattr(i1, "name")
    let n2 = synIDattr(i2, "name")
    echo n1 "->" n2
  endfor
endfunction

function! SynGroups()
  if !exists("*synstack")
    return
  endif
  echo map(synstack(line('.'), col('.')), 'synIDattr(v:val, "name")')
endfunc
