"" tab stuff
set ts=2 sw=2 sts=2 expandtab

" 256 colors
set t_Co=256

"" other stuff
set scrolloff=2
set title
set matchtime=1
set nowrap
set showmatch
let mapleader="\\"
let localleader=","

" "" smart indentation
" set smartindent

" latex should be default
let g:tex_flavor = "latex"

"" text width
set textwidth=72
set wrap

"" show unwanted whitespace
set list listchars=tab:\|\ ,trail:.

"" syntax highlighting
syntax enable

"" show line numbers
set number

" autoindent is helpful
set autoindent

" leader command section
nnoremap <leader>so     :so<SPACE>%<CR>
nnoremap <leader>vc     :e<SPACE>~/.vim/vimrc<CR>
nnoremap <leader>la     :e<SPACE>~/texmf/tex/latex/incertia/incertia.sty<CR>
nnoremap <leader>;      m`A;<ESC>``

"" autocmd stuff
if has("autocmd")
  " Uncomment the following to have Vim jump to the last position when
  " reopening a file
  au BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g'\"" | endif

  " Set scripts to be executable from the shell
  au BufWritePost * if getline(1) =~ "^#!" | if getline(1) =~ "/bin/" | silent execute "!chmod +x %" | endif | endif
  au BufWritePost * if getline(1) =~ "^#!" | if getline(1) =~ "zsh" | silent execute "setfiletype zsh" | endif | endif

  " Uncomment the following to have Vim load indentation rules and plugins
  " according to the detected filetype.
  filetype plugin indent on

  "" I don't know what this does
  au BufWrite * mkview
  au BufRead * silent loadview

  " Uncomment the following line to disable auto commenting
  au FileType * setlocal formatoptions-=c formatoptions-=r formatoptions-=o
endif

"folding settings
set foldmethod=indent   " fold based on indent
set foldnestmax=16      " deepest fold is 16 levels
set nofoldenable        " don't fold by default
set foldlevel=1         " yay

" number formats
set nf=alpha,octal,hex
nnoremap <C-x> <nop>
nnoremap <C-d> <C-x>

" split to the right and below
set splitbelow splitright

" map <F1> to deleting trailing whitespace and clearing empty lines
function! KillWhiteThings()
  let save_cursor = getpos(".")
  :silent! %s#\($\n\s*\)\+\%$##
  :silent! %s/\s\+$//g
  call setpos('.', save_cursor)
endfunction

nnoremap <silent> <F1>  :call KillWhiteThings()<CR>
nnoremap <silent> <F2>  :set hlsearch! hlsearch?<CR>
nnoremap <silent> <F3>  :tabonly<CR>
nnoremap <silent> <F4>  :q!<CR>

" reflow bindings
nnoremap Q              gqgq
vnoremap Q              gq

" emacs <C-x><C-c> with prompt is really nice
nnoremap <C-x><C-x>     :confirm qa<CR>

" switch files with arrow keys
nnoremap <DOWN>         :bnext<CR>
nnoremap <UP>           :bprev<CR>

" tabs
nnoremap <C-t>          :tabnew<SPACE>
let g:newtab_command = ":tabnew\<CR>"
nnoremap <C-y>          @=g:newtab_command<CR>
nnoremap <S-TAB>        gt

" tab navigation
function! TabSwitch(tabnum)
  call feedkeys(a:tabnum . "gt", "n")
endfunction

" :Tab commands
command! -nargs=1 TabSwitch :call TabSwitch(<f-args>)

" tab bindings
nnoremap <C-x><C-t>          :TabSwitch<SPACE>
nnoremap <C-x>t              :TabSwitch<SPACE>
nnoremap <leader>1           1gt
nnoremap <leader>2           2gt
nnoremap <leader>3           3gt
nnoremap <leader>4           4gt
nnoremap <leader>5           5gt
nnoremap <leader>6           6gt
nnoremap <leader>7           7gt
nnoremap <leader>8           8gt
nnoremap <leader>9           9gt
nnoremap <silent> <leader>0  :tablast<CR>

let g:tabmoveleft_cmd  = ":-tabmove\<CR>"
let g:tabmoveright_cmd = ":+tabmove\<CR>"
nnoremap <silent> <leader>hh @=g:tabmoveleft_cmd<CR>
nnoremap <silent> <leader>ll @=g:tabmoveright_cmd<CR>
nnoremap <leader>j           gt
nnoremap <leader>k           gT

" map space to executing the q macro for easy qq recording
nnoremap <SPACE>        @q

" map enter to execute the a macro
nnoremap <CR>           @a

" who cares about ex mode. map QQ to reflow paragraphs
" nnoremap QQ             gqap
" vnoremap QQ             gq

" save shortcut
inoremap <C-s>          <ESC>:w!<CR>a
nnoremap <C-s>          :w!<CR>

" split workflow
nnoremap <C-h>          <C-w>h
nnoremap <C-j>          <C-w>j
nnoremap <C-k>          <C-w>k
nnoremap <C-l>          <C-w>l
nnoremap <leader>-      <C-w>-
nnoremap <leader>=      <C-w>+
" because we remmaped <C-l>
nnoremap <C-m>          <C-l>

" scroll up to <C-q> (don't need this to be visual block)
nnoremap <C-q>          <C-y>

" this helps with long lines
nnoremap j              gj
nnoremap k              gk
nnoremap gj             j
nnoremap gk             k
vnoremap j              gj
vnoremap k              gk
vnoremap gj             j
vnoremap gk             k

function! Scroll(dir)
  let lines = winheight(0)

  if(a:dir == "up")
    let cmd = "\<C-y>"
  elseif(a:dir == "down")
    let cmd = "\<C-e>"
  else
    let cmd = "\<Esc>"
  endif

  call feedkeys(lines . cmd, "n")
endfunction

" change this emacs binding because j/k is more useful
nnoremap <silent> <C-n> :call Scroll("down")<CR>
nnoremap <silent> <C-p> :call Scroll("up")<CR>

" 2 line status bar
set laststatus=2

" good public/private indents?
set cinoptions=g-1,:0,(0

"" All of the following settings were taken from Damian Conway
"====[ Make the 81st column stand out ]====================

" EITHER the entire 81st column, full-screen
" highlight ColorColumn ctermbg=magenta
" set colorcolumn=81

" OR ELSE just the 81st column of wide lines
highlight ColorColumn ctermbg=magenta
call matchadd('ColorColumn', '\%81v', 100)


""=====[ Highlight matches when jumping to next ]=============
"
"    " This rewires n and N to do the highlighing
"    nnoremap <silent> n   n:call HLNext(0.4)<cr>
"    nnoremap <silent> N   N:call HLNext(0.4)<cr>
"
"
"    " OR ELSE just highlight the match in red
"    function! HLNext (blinktime)
"        let [bufnum, lnum, col, off] = getpos('.')
"        let matchlen = strlen(matchstr(strpart(getline('.'),col-1),@/))
"        let target_pat = '\c\%#'.@/
"        let ring = matchadd('WhiteOnRed', target_pat, 101)
"        redraw
"        exec 'sleep ' . float2nr(a:blinktime * 1000) . 'm'
"        call matchdelete(ring)
"        redraw
"    endfunction


"====[ Swap : and ; to make colon commands easier to type ]======

nnoremap  ;  :
nnoremap  :  ;
vnoremap  ;  :
vnoremap  :  ;


"====[ Swap v and CTRL-V, because Block mode is more useful that Visual mode "]======

nnoremap    v   <C-V>
nnoremap <C-V>     v

vnoremap    v   <C-V>
vnoremap <C-V>     v


"====[ Open any file with a pre-existing swapfile in readonly mode "]=========

"    augroup NoSimultaneousEdits
"        autocmd!
"        autocmd SwapExists * let v:swapchoice = 'o'
"        autocmd SwapExists * echomsg ErrorMsg
"        autocmd SwapExists * echo 'Duplicate edit session (readonly)'
"        autocmd SwapExists * echohl None
"        autocmd SwapExists * sleep 2
"    augroup END
"
"    " Also consider the autoswap_mac.vim plugin (but beware its limitations)

runtime plugin/dragvisuals.vim

vmap  <expr>  <LEFT>   DVB_Drag('left')
vmap  <expr>  <RIGHT>  DVB_Drag('right')
vmap  <expr>  <DOWN>   DVB_Drag('down')
vmap  <expr>  <UP>     DVB_Drag('up')
vmap  <expr>  D        DVB_Duplicate()

" Remove any introduced trailing whitespace after moving
let g:DVB_TrimWS = 1

" vimacs
" let g:VM_CmdHeightAdj = 0
" let g:VM_Enabled = 1

" pathogen
execute pathogen#infect()

if has("autocmd")
  au CompleteDone * pclose
endif
let g:ycm_min_num_of_chars_for_completion = 4
let g:ycm_key_list_select_completion = [ "<Down>", ]
let g:ycm_key_list_previous_completion = [ "<Up>", ]
let g:ycm_confirm_extra_conf = 0

" set the colorscheme to solarized-256
if has("gui_running")
  set background=light
else
  set background=dark
  let g:solarized_termcolors  = 256
  let g:solarized_termtrans   = 1
  let g:solarized_visibility  = "normal"
endif
colorscheme solarized

" enable powerline if it exists and we are not in a tty
if !(&term=~'linux') && isdirectory(expand("~/.vim/powerline"))
  set rtp+=~/.vim/powerline/powerline/bindings/vim/
endif
